const express = require('express');
const { body, validationResult, query } = require('express-validator');
const Ticket = require('../models/Ticket');
const TicketComment = require('../models/TicketComment');
const { authenticate } = require('../middleware/auth');
const { assignOfficeAndQueue } = require('../utils/queueManager');
const upload = require('../middleware/upload');
const fs = require('fs');
const path = require('path');

const router = express.Router();

// All ticket routes require authentication
router.use(authenticate);

// Validation middleware
const validateTicket = [
  body('title')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Title must be between 5 and 200 characters'),
  body('description')
    .trim()
    .isLength({ min: 10, max: 5000 })
    .withMessage('Description must be between 10 and 5000 characters'),
  body('category')
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Category must be between 1 and 200 characters')
    .custom((value) => {
      // Allow predefined categories OR custom categories (when "Other" was selected)
      const predefinedCategories = [
        'OTR Request',
        'Subject Enrollment',
        'Grade Inquiry',
        'Document Request',
        'Enrollment',
        'Scholarship',
        'Financial Aid',
        'Tuition Payment',
        'Academic Complaint',
        'Course Evaluation',
        'Library',
        'General Inquiry',
        'Technical Support',
        'Other',
      ];
      // Allow if it's a predefined category OR if it's a custom category (not "Other" and length >= 3)
      if (predefinedCategories.includes(value) || (value !== 'Other' && value.length >= 3)) {
        return true;
      }
      throw new Error('Invalid category');
    }),
  body('priority')
    .optional()
    .isIn(['Low', 'Normal', 'High', 'Urgent'])
    .withMessage('Invalid priority level'),
  body('requestDetails.numberOfCopies')
    .optional()
    .isInt({ min: 1, max: 10 })
    .withMessage('Number of copies must be between 1 and 10'),
  body('requestDetails.purpose')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Purpose cannot exceed 500 characters'),
  body('requestDetails.deliveryMethod')
    .optional()
    .isIn(['Pickup', 'Email', 'Mail', 'Digital Download'])
    .withMessage('Invalid delivery method'),
  body('requestDetails.subjectCode')
    .optional()
    .trim()
    .isLength({ max: 20 })
    .withMessage('Subject code cannot exceed 20 characters'),
  body('requestDetails.subjectName')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Subject name cannot exceed 200 characters'),
  body('requestDetails.studentId')
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage('Student ID cannot exceed 50 characters'),
  body('requestDetails.course')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Course cannot exceed 100 characters'),
];

/**
 * @route   POST /api/tickets
 * @desc    Create a new ticket
 * @access  Private (Authenticated users)
 */
router.post('/', validateTicket, async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array(),
      });
    }

    const {
      title,
      description,
      category,
      priority = 'Normal',
      requestDetails = {},
      attachments = [],
    } = req.body;

    // Create ticket
    const ticketData = {
      title,
      description,
      category,
      priority,
      createdBy: req.user.id,
      requestDetails,
      attachments: Array.isArray(attachments) ? attachments : [],
    };

    // Ensure ticketNumber is not in ticketData (it will be auto-generated by default function)
    delete ticketData.ticketNumber;
    
    const ticket = new Ticket(ticketData);
    
    // Assign office and queue number based on category
    await assignOfficeAndQueue(ticket, category);
    
    // Save ticket - the default function will automatically generate ticketNumber
    await ticket.save();

    // Populate creator information
    await ticket.populate('createdBy', 'username email firstName lastName');

    // Create a system comment to track ticket creation (non-blocking - if it fails, ticket is still created)
    try {
      const systemComment = new TicketComment({
        ticket: ticket._id,
        author: req.user.id,
        content: `Ticket created: ${title}`,
        isSystemNote: true,
      });
      await systemComment.save();
    } catch (commentError) {
      // Log but don't fail ticket creation if system comment fails
      console.error('Error creating system comment:', commentError);
    }

    res.status(201).json({
      success: true,
      message: 'Ticket created successfully',
      data: {
        ticket,
      },
    });
  } catch (error) {
    console.error('Create ticket error:', error);
    console.error('Error stack:', error.stack);
    console.error('Error name:', error.name);
    console.error('Error code:', error.code);
    console.error('Error message:', error.message);
    
    // Handle duplicate key error (ticketNumber uniqueness)
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern || {})[0] || 'field';
      return res.status(400).json({
        success: false,
        message: `A ticket with this ${field} already exists. Please try again.`,
        error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      });
    }
    
    // Handle validation errors
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map((err) => err.message);
      return res.status(400).json({
        success: false,
        message: 'Ticket validation failed',
        errors: messages,
        error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      });
    }
    
    res.status(500).json({
      success: false,
      message: error.message || 'Error creating ticket',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      errorDetails: process.env.NODE_ENV === 'development' ? {
        name: error.name,
        code: error.code,
        stack: error.stack,
      } : undefined,
    });
  }
});

/**
 * @route   GET /api/tickets
 * @desc    Get all tickets (with filters)
 * @access  Private
 */
router.get(
  '/',
  [
    query('status')
      .optional()
      .isIn(['Pending', 'In Review', 'Approved', 'Rejected', 'Completed', 'Cancelled', 'On Hold'])
      .withMessage('Invalid status'),
    query('category').optional().trim(),
    query('priority')
      .optional()
      .isIn(['Low', 'Normal', 'High', 'Urgent'])
      .withMessage('Invalid priority'),
    query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
    query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'),
    query('sortBy')
      .optional()
      .isIn(['createdAt', 'updatedAt', 'priority', 'status'])
      .withMessage('Invalid sort field'),
    query('sortOrder').optional().isIn(['asc', 'desc']).withMessage('Sort order must be asc or desc'),
    query('search').optional().trim().isLength({ max: 200 }).withMessage('Search query cannot exceed 200 characters'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: errors.array(),
        });
      }

      const {
        status,
        category,
        priority,
        search,
        page = 1,
        limit = 10,
        sortBy = 'createdAt',
        sortOrder = 'desc',
      } = req.query;

      // Build query - students see only their tickets, staff/admin see all
      const query = {};
      const userRole = req.user.role || 'student'; // Assuming you'll add role to User model later

      if (userRole === 'student' || !userRole) {
        query.createdBy = req.user.id;
      }

      if (status) query.status = status;
      if (category) query.category = category;
      if (priority) query.priority = priority;

      // Search functionality - search in title, description, ticket number, and request details
      if (search && search.trim()) {
        const searchRegex = new RegExp(search.trim(), 'i'); // Case-insensitive search
        query.$or = [
          { title: searchRegex },
          { description: searchRegex },
          { ticketNumber: searchRegex },
          { 'requestDetails.subjectCode': searchRegex },
          { 'requestDetails.subjectName': searchRegex },
          { 'requestDetails.studentId': searchRegex },
          { 'requestDetails.course': searchRegex },
        ];
      }

      // Calculate pagination
      const skip = (parseInt(page) - 1) * parseInt(limit);
      const sort = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

      // Get tickets
      const tickets = await Ticket.find(query)
        .populate('createdBy', 'username email firstName lastName')
        .populate('assignedTo', 'username email firstName lastName')
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit));

      // Get total count for pagination
      const total = await Ticket.countDocuments(query);

      res.json({
        success: true,
        data: {
          tickets,
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total,
            pages: Math.ceil(total / parseInt(limit)),
          },
        },
      });
    } catch (error) {
      console.error('Get tickets error:', error);
      res.status(500).json({
        success: false,
        message: 'Error fetching tickets',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      });
    }
  }
);

/**
 * Utility function to read categories from file
 */
const getCategories = () => {
  try {
    const categoriesPath = path.join(__dirname, '../data/categories.json');
    if (fs.existsSync(categoriesPath)) {
      const categoriesFile = fs.readFileSync(categoriesPath, 'utf8');
      const categories = JSON.parse(categoriesFile);
      if (Array.isArray(categories)) {
        return categories;
      }
      return [];
    }
    return [];
  } catch (error) {
    console.error('Error reading categories:', error);
    return [];
  }
};

/**
 * Utility function to read courses from file
 */
const getCourses = () => {
  try {
    const coursesPath = path.join(__dirname, '../data/courses.json');
    if (fs.existsSync(coursesPath)) {
      const coursesFile = fs.readFileSync(coursesPath, 'utf8');
      const courses = JSON.parse(coursesFile);
      if (Array.isArray(courses)) {
        return courses;
      }
      return [];
    }
    return [];
  } catch (error) {
    console.error('Error reading courses:', error);
    return [];
  }
};

/**
 * @route   GET /api/tickets/categories
 * @desc    Get all available categories
 * @access  Private
 */
router.get('/categories', async (req, res) => {
  try {
    const categories = getCategories();
    res.json({
      success: true,
      data: {
        categories,
      },
    });
  } catch (error) {
    console.error('Get categories error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Error fetching categories',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

/**
 * @route   GET /api/tickets/courses
 * @desc    Get all available courses
 * @access  Private
 */
router.get('/courses', async (req, res) => {
  try {
    const courses = getCourses();
    res.json({
      success: true,
      data: {
        courses,
      },
    });
  } catch (error) {
    console.error('Get courses error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Error fetching courses',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

/**
 * @route   GET /api/tickets/stats
 * @desc    Get ticket statistics
 * @access  Private
 */
router.get('/stats', async (req, res) => {
  try {
    const userRole = req.user.role || 'student';
    const stats = await Ticket.getStatistics(req.user.id, userRole);

    res.json({
      success: true,
      data: {
        statistics: stats,
      },
    });
  } catch (error) {
    console.error('Get statistics error:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching statistics',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

/**
 * @route   GET /api/tickets/:id
 * @desc    Get a single ticket by ID
 * @access  Private
 */
router.get('/:id', async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id)
      .populate('createdBy', 'username email firstName lastName')
      .populate('assignedTo', 'username email firstName lastName')
      .populate('resolution.resolvedBy', 'username email firstName lastName')
      .populate('receipt.uploadedBy', 'username email firstName lastName')
      .populate('receipt.reviewedBy', 'username email firstName lastName');

    if (!ticket) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    // Check if user has access to this ticket
    const userRole = req.user.role || 'student';
    if (
      (userRole === 'student' || !userRole) &&
      ticket.createdBy._id.toString() !== req.user.id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: 'Access denied. You can only view your own tickets.',
      });
    }

    // Get comments for this ticket
    const comments = await TicketComment.find({ ticket: ticket._id })
      .populate('author', 'username email firstName lastName')
      .sort({ createdAt: 1 });

    // Filter internal comments for students
    const filteredComments =
      userRole === 'student' || !userRole
        ? comments.filter((comment) => !comment.isInternal)
        : comments;

    res.json({
      success: true,
      data: {
        ticket,
        comments: filteredComments,
      },
    });
  } catch (error) {
    console.error('Get ticket error:', error);
    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid ticket ID',
      });
    }
    res.status(500).json({
      success: false,
      message: 'Error fetching ticket',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

/**
 * @route   PUT /api/tickets/:id
 * @desc    Update a ticket
 * @access  Private (Creator or Staff/Admin)
 */
router.put('/:id', validateTicket, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array(),
      });
    }

    const ticket = await Ticket.findById(req.params.id);

    if (!ticket) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    // Check permissions - only creator can update, or staff/admin
    const userRole = req.user.role || 'student';
    const isCreator = ticket.createdBy.toString() === req.user.id.toString();
    const isStaff = userRole === 'staff' || userRole === 'admin';

    if (!isCreator && !isStaff) {
      return res.status(403).json({
        success: false,
        message: 'Access denied. You can only update your own tickets.',
      });
    }

    // Students can only update tickets that are Pending or Cancelled
    if (isCreator && !isStaff && !['Pending', 'Cancelled'].includes(ticket.status)) {
      return res.status(403).json({
        success: false,
        message: 'Cannot update ticket. It has already been processed.',
      });
    }

    const { title, description, category, priority, requestDetails, attachments } = req.body;

    // Update ticket fields
    if (title) ticket.title = title;
    if (description) ticket.description = description;
    if (category) ticket.category = category;
    if (priority) ticket.priority = priority;
    if (requestDetails) {
      ticket.requestDetails = { ...ticket.requestDetails, ...requestDetails };
    }
    if (attachments) ticket.attachments = attachments;

    await ticket.save();
    await ticket.populate('createdBy', 'username email firstName lastName');
    await ticket.populate('assignedTo', 'username email firstName lastName');

    // Create system comment for update
    const updateComment = new TicketComment({
      ticket: ticket._id,
      author: req.user.id,
      content: 'Ticket information updated',
      isSystemNote: true,
    });
    await updateComment.save();

    res.json({
      success: true,
      message: 'Ticket updated successfully',
      data: {
        ticket,
      },
    });
  } catch (error) {
    console.error('Update ticket error:', error);
    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid ticket ID',
      });
    }
    res.status(500).json({
      success: false,
      message: 'Error updating ticket',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

/**
 * @route   PUT /api/tickets/:id/status
 * @desc    Update ticket status (Staff/Admin only, or creator can cancel)
 * @access  Private
 */
router.put(
  '/:id/status',
  [
    body('status')
      .isIn(['Pending', 'In Review', 'Approved', 'Rejected', 'Completed', 'Cancelled', 'On Hold'])
      .withMessage('Invalid status'),
    body('rejectionReason')
      .optional()
      .trim()
      .isLength({ max: 1000 })
      .withMessage('Rejection reason cannot exceed 1000 characters'),
    body('resolutionNotes')
      .optional()
      .trim()
      .isLength({ max: 2000 })
      .withMessage('Resolution notes cannot exceed 2000 characters'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: errors.array(),
        });
      }

      const ticket = await Ticket.findById(req.params.id);

      if (!ticket) {
        return res.status(404).json({
          success: false,
          message: 'Ticket not found',
        });
      }

      const { status, rejectionReason, resolutionNotes } = req.body;
      const userRole = req.user.role || 'student';
      const isCreator = ticket.createdBy.toString() === req.user.id.toString();
      const isStaff = userRole === 'staff' || userRole === 'admin';

      // Only creator can cancel, staff/admin can change any status
      if (status === 'Cancelled') {
        if (!isCreator && !isStaff) {
          return res.status(403).json({
            success: false,
            message: 'Only the ticket creator can cancel a ticket',
          });
        }
        if (!['Pending', 'In Review'].includes(ticket.status)) {
          return res.status(400).json({
            success: false,
            message: 'Cannot cancel ticket in current status',
          });
        }
      } else {
        // For other status changes, only staff/admin can do it
        if (!isStaff) {
          return res.status(403).json({
            success: false,
            message: 'Only staff or admin can update ticket status',
          });
        }
      }

      const oldStatus = ticket.status;
      ticket.status = status;

      // Handle rejection
      if (status === 'Rejected' && rejectionReason) {
        ticket.resolution.rejectionReason = rejectionReason;
      }

      // Handle resolution notes
      if (['Completed', 'Approved'].includes(status) && resolutionNotes) {
        ticket.resolution.resolutionNotes = resolutionNotes;
      }

      // Set resolvedBy if not already set
      if (['Completed', 'Rejected'].includes(status) && !ticket.resolution.resolvedBy) {
        ticket.resolution.resolvedBy = req.user.id;
      }

      await ticket.save();

      // Create comment for status change
      const statusComment = new TicketComment({
        ticket: ticket._id,
        author: req.user.id,
        content: `Status changed from "${oldStatus}" to "${status}"${rejectionReason ? `\nReason: ${rejectionReason}` : ''}${resolutionNotes ? `\nNotes: ${resolutionNotes}` : ''}`,
        isSystemNote: true,
      });
      await statusComment.save();

      await ticket.populate('createdBy', 'username email firstName lastName');
      await ticket.populate('assignedTo', 'username email firstName lastName');

      res.json({
        success: true,
        message: 'Ticket status updated successfully',
        data: {
          ticket,
        },
      });
    } catch (error) {
      console.error('Update status error:', error);
      if (error.name === 'CastError') {
        return res.status(400).json({
          success: false,
          message: 'Invalid ticket ID',
        });
      }
      res.status(500).json({
        success: false,
        message: 'Error updating ticket status',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      });
    }
  }
);

/**
 * @route   PUT /api/tickets/:id/assign
 * @desc    Assign ticket to staff member (Staff/Admin only)
 * @access  Private
 */
router.put(
  '/:id/assign',
  [body('assignedTo').isMongoId().withMessage('Invalid user ID')],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: errors.array(),
        });
      }

      const ticket = await Ticket.findById(req.params.id);

      if (!ticket) {
        return res.status(404).json({
          success: false,
          message: 'Ticket not found',
        });
      }

      const userRole = req.user.role || 'student';
      if (userRole !== 'staff' && userRole !== 'admin') {
        return res.status(403).json({
          success: false,
          message: 'Only staff or admin can assign tickets',
        });
      }

      ticket.assignedTo = req.body.assignedTo;
      await ticket.save();

      // Create comment for assignment
      const assignComment = new TicketComment({
        ticket: ticket._id,
        author: req.user.id,
        content: `Ticket assigned to staff member`,
        isSystemNote: true,
      });
      await assignComment.save();

      await ticket.populate('createdBy', 'username email firstName lastName');
      await ticket.populate('assignedTo', 'username email firstName lastName');

      res.json({
        success: true,
        message: 'Ticket assigned successfully',
        data: {
          ticket,
        },
      });
    } catch (error) {
      console.error('Assign ticket error:', error);
      if (error.name === 'CastError') {
        return res.status(400).json({
          success: false,
          message: 'Invalid ticket or user ID',
        });
      }
      res.status(500).json({
        success: false,
        message: 'Error assigning ticket',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined,
      });
    }
  }
);

/**
 * @route   DELETE /api/tickets/:id
 * @desc    Delete a ticket (Only creator can delete pending tickets, or admin)
 * @access  Private
 */
router.delete('/:id', async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id);

    if (!ticket) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    const userRole = req.user.role || 'student';
    const isCreator = ticket.createdBy.toString() === req.user.id.toString();
    const isAdmin = userRole === 'admin';

    // Only creator can delete pending tickets, or admin can delete any
    if (isAdmin) {
      // Admin can delete any ticket
    } else if (isCreator && ticket.status === 'Pending') {
      // Creator can only delete pending tickets
    } else {
      return res.status(403).json({
        success: false,
        message: 'You do not have permission to delete this ticket',
      });
    }

    // Delete associated comments
    await TicketComment.deleteMany({ ticket: ticket._id });

    // Delete ticket
    await Ticket.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: 'Ticket deleted successfully',
    });
  } catch (error) {
    console.error('Delete ticket error:', error);
    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid ticket ID',
      });
    }
    res.status(500).json({
      success: false,
      message: 'Error deleting ticket',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

/**
 * @route   POST /api/tickets/:id/receipt
 * @desc    Upload receipt for a ticket
 * @access  Private (Ticket creator only)
 */
router.post('/:id/receipt', authenticate, upload.single('receipt'), async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id);

    if (!ticket) {
      // Delete uploaded file if ticket not found
      if (req.file) {
        const fs = require('fs');
        fs.unlinkSync(req.file.path);
      }
      return res.status(404).json({
        success: false,
        message: 'Ticket not found',
      });
    }

    // Check if user is the ticket creator
    if (ticket.createdBy.toString() !== req.user.id.toString()) {
      // Delete uploaded file if unauthorized
      if (req.file) {
        const fs = require('fs');
        fs.unlinkSync(req.file.path);
      }
      return res.status(403).json({
        success: false,
        message: 'You can only upload receipts for your own tickets',
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No file uploaded',
      });
    }

    // Delete old receipt file if it exists
    if (ticket.receipt && ticket.receipt.fileUrl) {
      const fs = require('fs');
      const oldFilePath = path.join(__dirname, '../', ticket.receipt.fileUrl);
      if (fs.existsSync(oldFilePath)) {
        fs.unlinkSync(oldFilePath);
      }
    }

    // Update ticket with receipt information
    ticket.receipt = {
      filename: req.file.filename,
      fileUrl: `/uploads/receipts/${req.file.filename}`,
      uploadedAt: new Date(),
      uploadedBy: req.user.id,
      status: 'Pending',
      reviewedBy: null,
      reviewedAt: null,
      adminComment: null,
    };

    await ticket.save();

    // Create a system comment
    const comment = new TicketComment({
      ticket: ticket._id,
      author: req.user.id,
      content: 'Receipt uploaded',
      isSystemNote: true,
    });
    await comment.save();

    await ticket.populate('createdBy', 'username email firstName lastName');
    await ticket.populate('receipt.uploadedBy', 'username email firstName lastName');

    res.json({
      success: true,
      message: 'Receipt uploaded successfully',
      data: {
        ticket,
      },
    });
  } catch (error) {
    console.error('Upload receipt error:', error);
    // Delete uploaded file on error
    if (req.file) {
      const fs = require('fs');
      fs.unlinkSync(req.file.path);
    }
    if (error.name === 'CastError') {
      return res.status(400).json({
        success: false,
        message: 'Invalid ticket ID',
      });
    }
    res.status(500).json({
      success: false,
      message: error.message || 'Error uploading receipt',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
});

module.exports = router;

